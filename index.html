<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-app.js';
  import { getFirestore, collection, query, onSnapshot, doc, updateDoc, addDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.13.1/firebase-firestore.js';

  const firebaseConfig = {
    apiKey: "AIzaSyAbKXYb0ImzYCoyzG8pM70S2k3hilCppE",
    authDomain: "drone-team-rotation.firebaseapp.com",
    projectId: "drone-team-rotation",
    storageBucket: "drone-team-rotation.firebasestorage.app",
    messagingSenderId: "972886553431",
    appId: "1:972886553431:web:c7253c4c8862e921720412",
    measurementId: "G-VF7HF4EC4S"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const isDisplayOnly = new URLSearchParams(window.location.search).get('display') === '1';
  document.body.classList.toggle('no-drag', isDisplayOnly);

  const lists = {
    tables: document.getElementById('tables'),
    waitA: document.getElementById('waitA'),
    ondeckA: document.getElementById('ondeckA'),
    inA: document.getElementById('inA'),
    waitB: document.getElementById('waitB'),
    ondeckB: document.getElementById('ondeckB'),
    inB: document.getElementById('inB')
  };

  const stationMap = {
    tables: null,
    waitA: 'waitA',
    ondeckA: 'ondeckA',
    inA: 'inA',
    waitB: 'waitB',
    ondeckB: 'ondeckB',
    inB: 'inB'
  };

  // === ROTATE FUNCTION ===
  async function rotateWarehouses() {
    try {
      const getFirstTeam = (listId) => {
        const el = lists[listId];
        if (!el || el.children.length === 0) return null;
        return el.children[0].dataset.id;
      };

      const moveTeam = async (teamId, newStation) => {
        if (!teamId) return;
        await updateDoc(doc(db, 'teams', teamId), {
          station: newStation,
          updatedAt: serverTimestamp()
        });
      };

      const warehouseAId = getFirstTeam('inA');
      const ondeckAId = getFirstTeam('ondeckA');
      const waitingATopId = getFirstTeam('waitA');
      const warehouseBId = getFirstTeam('inB');
      const ondeckBId = getFirstTeam('ondeckB');
      const waitingBTopId = getFirstTeam('waitB');

      await Promise.all([
        moveTeam(warehouseAId, null),
        moveTeam(ondeckAId, 'inA'),
        moveTeam(waitingATopId, 'ondeckA'),
        moveTeam(warehouseBId, null),
        moveTeam(ondeckBId, 'inB'),
        moveTeam(waitingBTopId, 'ondeckB')
      ]);

      console.log("Rotation complete!");
    } catch (err) {
      console.error("Rotate failed:", err);
      alert("Rotation failed.");
    }
  }

  function listenToTeams() {
    const q = query(collection(db, 'teams'));
    onSnapshot(q, (snapshot) => {
      Object.values(lists).forEach(list => list.innerHTML = '');
      snapshot.docs.forEach(docSnap => {
        const team = docSnap.data();
        const station = team.station || null;
        let target = lists.tables;
        if (station === 'waitA') target = lists.waitA;
        else if (station === 'ondeckA') target = lists.ondeckA;
        else if (station === 'inA') target = lists.inA;
        else if (station === 'waitB') target = lists.waitB;
        else if (station === 'ondeckB') target = lists.ondeckB;
        else if (station === 'inB') target = lists.inB;

        const card = document.createElement('div');
        card.className = 'team-card';
        card.dataset.id = docSnap.id;
        card.draggable = !isDisplayOnly;
        card.textContent = team.teamName;
        target.appendChild(card);
      });
      initSortable();
    }, (error) => {
      console.error("Firestore error:", error);
    });
  }

  function initSortable() {
    if (isDisplayOnly) return;
    Object.values(lists).forEach(list => {
      if (list && list.sortable) list.sortable.destroy();
    });
    Object.keys(lists).forEach(key => {
      const el = lists[key];
      if (!el) return;
      const sortable = new Sortable(el, {
        group: 'teams',
        animation: 150,
        ghostClass: 'sortable-ghost',
        onEnd: async (evt) => {
          const teamId = evt.item.dataset.id;
          const newStation = stationMap[evt.to.id];
          try {
            await updateDoc(doc(db, 'teams', teamId), {
              station: newStation,
              updatedAt: serverTimestamp()
            });
          } catch (err) {
            console.error("Move failed:", err);
          }
        }
      });
      el.sortable = sortable;

      // Max limits
      if (key === 'waitA' || key === 'waitB') sortable.option('max', 3);
      if (['ondeckA', 'ondeckB', 'inA', 'inB'].includes(key)) sortable.option('max', 1);
    });
  }

  listenToTeams();

  // === BUTTONS ===
  if (!isDisplayOnly) {
    // Add Team
    const addBtn = document.createElement('button');
    addBtn.innerText = '+ Add Team';
    addBtn.className = 'btn btn-success';
    addBtn.style.cssText = 'position:fixed;top:10px;right:10px;z-index:1000;';
    addBtn.onclick = async () => {
      const name = prompt('Team name?');
      if (name?.trim()) {
        await addDoc(collection(db, 'teams'), {
          teamName: name.trim(),
          station: null,
          createdAt: serverTimestamp()
        });
      }
    };
    document.body.appendChild(addBtn);

    // Rotate
    const rotateBtn = document.createElement('button');
    rotateBtn.innerText = 'ROTATE';
    rotateBtn.className = 'btn btn-danger btn-lg';
    rotateBtn.style.cssText = 'position:fixed;top:10px;right:140px;z-index:1000;font-weight:bold;';
    rotateBtn.onclick = async () => {
      if (confirm('Rotate both warehouses?')) {
        await rotateWarehouses();
      }
    };
    document.body.appendChild(rotateBtn);
  }
</script>
